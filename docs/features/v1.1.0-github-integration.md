# v1.1.0: GitHub API Integration

> Connect check-my-process to the GitHub API to perform real PR validation.

## Overview

v1.0.0 established the CLI skeleton and TOML config loader. v1.1.0 adds the core functionality: fetching PR data from GitHub and running actual checks against the configured rules.

## Goals

| Goal               | Success Criteria                                                  |
| ------------------ | ----------------------------------------------------------------- |
| Fetch PR metadata  | Can retrieve PR title, body, branch, files changed, lines changed |
| Fetch review data  | Can retrieve approval count and reviewer info                     |
| Run PR size checks | Validates max_files and max_lines against config                  |
| Run approval check | Validates min_approvals against config                            |
| Run branch check   | Validates branch name against pattern                             |
| Run ticket check   | Finds ticket references in configured locations                   |

## Non-Goals

- GitHub Action packaging (v1.4.0)
- Remote standards inheritance (v1.2.0+)
- Commit message validation (v1.3.0)
- SARIF output format (future)

## Technical Design

### Dependencies

```json
{
  "@octokit/rest": "^21.0.0"
}
```

### Architecture

```
src/
├── github/
│   ├── client.ts        # Octokit wrapper, auth handling
│   ├── types.ts         # GitHub API response types
│   └── index.ts         # Public exports
├── checks/
│   ├── engine.ts        # Orchestrates all checks
│   ├── types.ts         # CheckResult, CheckContext types
│   ├── pr-size.ts       # max_files, max_lines checks
│   ├── approvals.ts     # min_approvals check
│   ├── branch.ts        # branch naming pattern check
│   ├── ticket.ts        # ticket reference check
│   └── index.ts         # Public exports
└── cli.ts               # Updated check command
```

### GitHub Client

```typescript
// src/github/client.ts
import { Octokit } from "@octokit/rest";

export interface GitHubClientOptions {
  token: string;
  baseUrl?: string; // For GitHub Enterprise
}

export interface PullRequestData {
  number: number;
  title: string;
  body: string | null;
  branch: string;
  baseBranch: string;
  author: string;
  filesChanged: number;
  additions: number;
  deletions: number;
  approvalCount: number;
  reviewers: string[];
}

export function createGitHubClient(options: GitHubClientOptions): GitHubClient;

export class GitHubClient {
  async getPullRequest(owner: string, repo: string, prNumber: number): Promise<PullRequestData>;
}
```

### Check Engine

```typescript
// src/checks/types.ts
export type CheckStatus = "passed" | "failed" | "skipped";

export interface CheckResult {
  rule: string;
  status: CheckStatus;
  message: string;
  expected?: string | number;
  actual?: string | number;
  severity: "error" | "warning";
}

export interface CheckContext {
  pr: PullRequestData;
  config: Config;
}

export type CheckFn = (ctx: CheckContext) => CheckResult;

// src/checks/engine.ts
export function runChecks(ctx: CheckContext): CheckResult[];
```

### Individual Checks

#### PR Size Check

```typescript
// src/checks/pr-size.ts
export function checkMaxFiles(ctx: CheckContext): CheckResult {
  const maxFiles = ctx.config.pr?.max_files;
  if (!maxFiles) return { rule: "pr.max_files", status: "skipped", ... };

  const passed = ctx.pr.filesChanged <= maxFiles;
  return {
    rule: "pr.max_files",
    status: passed ? "passed" : "failed",
    message: passed
      ? `${ctx.pr.filesChanged} files (max: ${maxFiles})`
      : `${ctx.pr.filesChanged} files exceeds limit of ${maxFiles}`,
    expected: maxFiles,
    actual: ctx.pr.filesChanged,
    severity: ctx.config.pr?.severity ?? ctx.config.settings.default_severity,
  };
}

export function checkMaxLines(ctx: CheckContext): CheckResult {
  const maxLines = ctx.config.pr?.max_lines;
  if (!maxLines) return { rule: "pr.max_lines", status: "skipped", ... };

  const totalLines = ctx.pr.additions + ctx.pr.deletions;
  const passed = totalLines <= maxLines;
  return {
    rule: "pr.max_lines",
    status: passed ? "passed" : "failed",
    message: passed
      ? `${totalLines} lines (max: ${maxLines})`
      : `${totalLines} lines exceeds limit of ${maxLines}`,
    expected: maxLines,
    actual: totalLines,
    severity: ctx.config.pr?.severity ?? ctx.config.settings.default_severity,
  };
}
```

#### Approvals Check

```typescript
// src/checks/approvals.ts
export function checkMinApprovals(ctx: CheckContext): CheckResult {
  const minApprovals = ctx.config.pr?.min_approvals;
  if (!minApprovals) return { rule: "pr.min_approvals", status: "skipped", ... };

  const passed = ctx.pr.approvalCount >= minApprovals;
  return {
    rule: "pr.min_approvals",
    status: passed ? "passed" : "failed",
    message: passed
      ? `${ctx.pr.approvalCount} approvals (min: ${minApprovals})`
      : `${ctx.pr.approvalCount} approvals, need ${minApprovals}`,
    expected: minApprovals,
    actual: ctx.pr.approvalCount,
    severity: ctx.config.pr?.severity ?? ctx.config.settings.default_severity,
  };
}
```

#### Branch Check

```typescript
// src/checks/branch.ts
export function checkBranchPattern(ctx: CheckContext): CheckResult {
  const pattern = ctx.config.branch?.pattern;
  if (!pattern) return { rule: "branch.pattern", status: "skipped", ... };

  const regex = new RegExp(pattern);
  const passed = regex.test(ctx.pr.branch);
  return {
    rule: "branch.pattern",
    status: passed ? "passed" : "failed",
    message: passed
      ? `Branch "${ctx.pr.branch}" matches pattern`
      : `Branch "${ctx.pr.branch}" doesn't match pattern`,
    expected: pattern,
    actual: ctx.pr.branch,
    severity: ctx.config.branch?.severity ?? ctx.config.settings.default_severity,
  };
}
```

#### Ticket Check

```typescript
// src/checks/ticket.ts
export function checkTicketReference(ctx: CheckContext): CheckResult {
  const pattern = ctx.config.ticket?.pattern;
  const checkIn = ctx.config.ticket?.check_in ?? ["title", "branch", "body"];

  if (!pattern) return { rule: "ticket.pattern", status: "skipped", ... };

  const regex = new RegExp(pattern);
  const locations: Record<string, string | null> = {
    title: ctx.pr.title,
    branch: ctx.pr.branch,
    body: ctx.pr.body,
  };

  const foundIn: string[] = [];
  for (const loc of checkIn) {
    const text = locations[loc];
    if (text && regex.test(text)) {
      foundIn.push(loc);
    }
  }

  const passed = foundIn.length > 0;
  return {
    rule: "ticket.pattern",
    status: passed ? "passed" : "failed",
    message: passed
      ? `Ticket found in: ${foundIn.join(", ")}`
      : `No ticket reference found in: ${checkIn.join(", ")}`,
    expected: pattern,
    severity: ctx.config.ticket?.severity ?? ctx.config.settings.default_severity,
  };
}
```

### CLI Updates

```typescript
// src/cli.ts (check command)
.action(async (options) => {
  const config = loadConfig(options.config);
  const token = process.env.GITHUB_TOKEN;

  if (!token) {
    console.error("Error: GITHUB_TOKEN environment variable is required");
    process.exit(1);
  }

  const [owner, repo] = options.repo.split("/");
  const prNumber = parseInt(options.pr, 10);

  const client = createGitHubClient({ token });
  const pr = await client.getPullRequest(owner, repo, prNumber);

  const results = runChecks({ pr, config });

  if (options.format === "json") {
    console.log(JSON.stringify(results, null, 2));
  } else {
    printResults(results);
  }

  const hasErrors = results.some(r => r.status === "failed" && r.severity === "error");
  process.exit(hasErrors ? 1 : 0);
});
```

### Output Format

```
$ cmp check --repo owner/repo --pr 123

check-my-process v1.1.0

Checking PR #123 in owner/repo...

Pull Request
  ✓ pr.max_files: 8 files (max: 20)
  ✓ pr.max_lines: 142 lines (max: 400)
  ✓ pr.min_approvals: 2 approvals (min: 1)

Branch
  ✗ branch.pattern: Branch "fix-bug" doesn't match pattern
    Expected: ^(feature|fix|hotfix)/[A-Z]+-[0-9]+-[a-z0-9-]+$

Ticket
  ✓ ticket.pattern: Ticket found in: title, branch

──────────────────────────────────────────────
Result: 4 passed, 1 failed
```

## Authentication

The GitHub token is read from the `GITHUB_TOKEN` environment variable. This is the standard approach used by:

- GitHub Actions (`${{ secrets.GITHUB_TOKEN }}`)
- GitHub CLI (`gh auth token`)
- Most GitHub tools

For GitHub Enterprise, users can set `GITHUB_API_URL` to override the base URL.

## Error Handling

| Scenario             | Behavior                                    |
| -------------------- | ------------------------------------------- |
| Missing GITHUB_TOKEN | Exit with error message                     |
| Invalid token        | Exit with "authentication failed" message   |
| PR not found         | Exit with "PR #X not found in owner/repo"   |
| Rate limited         | Exit with rate limit message and reset time |
| Network error        | Exit with connection error message          |

## Testing Strategy

### Unit Tests

- Mock Octokit responses for GitHub client tests
- Test each check function with various inputs
- Test check engine aggregation

### Integration Tests

- Use recorded fixtures for real API responses
- Test full CLI flow with mocked GitHub client

### Manual Testing

```bash
# Set up token
export GITHUB_TOKEN=$(gh auth token)

# Test against a real PR
cmp check --repo owner/repo --pr 123

# Test with custom config
cmp check --repo owner/repo --pr 123 --config ./custom.toml

# Test JSON output
cmp check --repo owner/repo --pr 123 --format json
```

## Rollout

1. Implement GitHub client with PR fetching
2. Implement check functions (one at a time, with tests)
3. Implement check engine
4. Update CLI check command
5. Add JSON output format
6. Update README with usage examples

## Future Versions

| Version | Feature                      |
| ------- | ---------------------------- |
| v1.2.0  | Remote standards inheritance |
| v1.3.0  | Commit message validation    |
| v1.4.0  | GitHub Action packaging      |
| v1.5.0  | SARIF output format          |

## Future Considerations

- **Caching**: Cache PR data within a run to avoid duplicate API calls
- **Parallel checks**: Run independent checks concurrently
- **GraphQL**: Consider switching to GraphQL for more efficient data fetching
- **Retry logic**: Add exponential backoff for transient failures
